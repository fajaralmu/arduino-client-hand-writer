<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Movement Simulator</title>
    <script src="Output/data.js"></script>
    <script type="text/javascript">
      const PX_PER_CM = 10;
      const setting = {
        armBaseLength: 15.5 * PX_PER_CM,
        armSecondaryLength: 16.3 * PX_PER_CM,

        armSecondaryAngleAdjustment: 5,
        armPenDownAngle: 30,

        delayBeforeTogglePen: 500,
        tolerance: 0.1,

        portName: "COM7",
        baudRate: 9600,
      };

      const width = 2 * (setting.armBaseLength + setting.armSecondaryLength);
      const height = setting.armBaseLength + setting.armSecondaryLength;
      let paths = [{"alpha":41,"beta":42,"omega":34,"theta":91,"x":0.886277379160064,"y":13.514567981147152,"xString":"0.89","yString":"13.51"}];
      paths = calculatedPaths;

      function Cos(angle) {
        return Math.cos(rad(angle));
      }
      function Sin(angle) {
        return Math.sin(rad(angle));
      }
      function rad(angle) {
        return (angle * Math.PI) / 180;
      }
    </script>
    <style>
      * {
        font-family: Arial, Helvetica, sans-serif;
      }
      #canvas {
        background-color: cadetblue;
        margin: auto;
      }
      #container {
        text-align: center;
        height: 100%;
        padding: 50px;
      }
      .small {
        font: italic 20px sans-serif;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <h2>Simulation</h2>
      <svg id="canvas">
        <g id="path-content"></g>
        <g id="point-content"></g>
      </svg>
    </div>
    <script type="text/javascript">
      const svg = document.getElementById("canvas");
      const pathContent = document.getElementById("path-content");
      const pointContent = document.getElementById("point-content");
      let currentPathIndex = 0;
      let originX = width / 2;
      let originY = height;

      function init() {
        svg.setAttribute("width", width);
        svg.setAttribute("height", height);

        drawOriginPoint();
        drawPaths();
      }

      function drawOriginPoint() {
        // <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        svg.appendChild(createCircle(originX, originY, "red"));
      }
    
      let timeout;

      function drawPaths() {
        if (timeout) {
          clearTimeout(timeout);
        }
        const path = paths[currentPathIndex];

        //  console.log("Draw path", timeout, " Coordinate: ",  path.xString, path.yString);

        pathContent.innerHTML = "";

        // construct pathData
        let baseHorLength = setting.armBaseLength * Cos(path.alpha);
        let baseVerLength = setting.armBaseLength * Sin(path.alpha);
        const baseArmXAdjusted = originX - baseHorLength;
        const baseArmYAdjusted = originY - baseVerLength;

        let secondaryHorLength = setting.armSecondaryLength * Cos(path.beta);
        let secondaryVerLength = setting.armSecondaryLength * Sin(path.beta);
        const secondaryArmXAdjusted = baseArmXAdjusted - secondaryHorLength;
        const secondaryArmYAdjusted = baseArmYAdjusted - secondaryVerLength;

        let pathData = `M ${originX} ${originY} 
                        L ${baseArmXAdjusted} ${baseArmYAdjusted} 
                        L ${secondaryArmXAdjusted} ${secondaryArmYAdjusted}`;
        console.log();
        console.log("Expected point", path.x  * PX_PER_CM, path.y  * PX_PER_CM);
        console.log("Actual point", secondaryArmXAdjusted, secondaryArmYAdjusted);
        const pathElement = commonPath(pathData);
        pathContent.appendChild(pathElement);

        // Print angle
        pathContent.appendChild(createText(originX, originY, path.alpha));
        pathContent.appendChild(
          createText(baseArmXAdjusted, baseArmYAdjusted, path.beta)
        );

        // Exptected
        pointContent.appendChild(
          createCircle(path.x * PX_PER_CM, height - path.y * PX_PER_CM, "red")
        );
        // Actual
        pointContent.appendChild(
          createCircle(secondaryArmXAdjusted, secondaryArmYAdjusted, "green")
        );

        currentPathIndex++;

        if (currentPathIndex == paths.length) {
          currentPathIndex = 0;
          return;
        }

        timeout = setTimeout(() => {
          drawPaths();
        }, 500);
      }

      /////////////// Svg Elements ///////////////

      function createCircle(x, y, color, r = 3) {
        const circle = createSvgElement("circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", r);
        circle.setAttribute("fill", color);
        return circle;
      }

      function createText(x, y, text) {
        const txt = createSvgElement("text");
        txt.setAttribute("x", x);
        txt.setAttribute("y", y);
        txt.setAttribute("class", "small");
        txt.innerHTML = text;
        return txt;
      }

      function commonPath(d) {
        const path = createSvgElement("path");
        path.setAttribute("d", d);
        path.setAttribute("stroke", "#000");
        path.setAttribute("stroke-width", "3");
        path.setAttribute("fill", "none");
        return path;
      }

      function createSvgElement(tag) {
        return document.createElementNS("http://www.w3.org/2000/svg", tag);
      }

      init();
    </script>
  </body>
</html>
